<!doctype html>
<meta charset="utf-8">
<title>Live SVG</title>
<style>
  html, body {
    margin: 0;
    height: 100%;
    background: #fff;
    color: #222;
    font-family: system-ui, sans-serif;
  }

  #toolbar {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.75rem 1rem;
    background: #f2f2f2;
    border-bottom: 1px solid #ddd;
  }

  #pickButton {
    padding: 0.45rem 0.9rem;
    border-radius: 4px;
    border: 1px solid #888;
    background: #fff;
    cursor: pointer;
  }

  #pickButton:hover {
    background: #e9e9e9;
  }

  #status {
    flex: 1;
    min-height: 1.2em;
    font-size: 0.9rem;
    color: #444;
  }

  #viewer {
    width: 100%;
    height: calc(100% - 56px);
    overflow: hidden;
  }

  object {
    width: 100%;
    height: 100%;
    display: none;
  }
</style>

<div id="toolbar">
  <button id="pickButton" type="button">Selecionar SVG...</button>
  <span id="status"></span>
</div>
<div id="viewer">
  <object id="preview" type="image/svg+xml"></object>
</div>
<input id="fileInput" type="file" accept=".svg,image/svg+xml" hidden>

<script>
  const pickButton = document.getElementById('pickButton');
  const statusEl = document.getElementById('status');
  const preview = document.getElementById('preview');
  const fileInput = document.getElementById('fileInput');

  const REFRESH_INTERVAL_MS = 1000;
  const ZOOM_FACTOR = 10; // Ajuste o nivel de zoom desejado.
  const OFFSET_X = 50; // Deslocamento horizontal do recorte.
  const OFFSET_Y = 0; // Deslocamento vertical do recorte.

  let fileHandle = null;
  let baseViewBox = null;
  let lastModified = 0;
  let currentObjectUrl = null;
  let refreshTimer = null;
  let isRefreshing = false;

  const supportsFileSystemAccess = () =>
    typeof window.showOpenFilePicker === 'function';

  const updateStatus = (message) => {
    statusEl.textContent = message ?? '';
  };

  const parseViewBox = (value) => {
    const parts = value.trim().split(/[ ,]+/).map(Number);
    if (parts.length === 4 && parts.every(Number.isFinite)) {
      return {
        minX: parts[0],
        minY: parts[1],
        width: parts[2],
        height: parts[3],
      };
    }
    return null;
  };

  const computeBaseViewBox = (svg) => {
    const vb = svg.getAttribute('viewBox');
    if (vb) {
      const parsed = parseViewBox(vb);
      if (parsed) {
        return parsed;
      }
    }
    const widthAttr = svg.getAttribute('width');
    const heightAttr = svg.getAttribute('height');
    const width = widthAttr ? parseFloat(widthAttr) : NaN;
    const height = heightAttr ? parseFloat(heightAttr) : NaN;
    if (
      Number.isFinite(width) &&
      Number.isFinite(height) &&
      width > 0 &&
      height > 0
    ) {
      return { minX: 0, minY: 0, width, height };
    }
    return { minX: 0, minY: 0, width: 100, height: 100 };
  };

  const ensurePermission = async (handle) => {
    if (!handle || typeof handle.queryPermission !== 'function') {
      return true;
    }
    const opts = { mode: 'read' };
    let permission = await handle.queryPermission(opts);
    if (permission === 'granted') {
      return true;
    }
    if (permission === 'prompt') {
      permission = await handle.requestPermission(opts);
      return permission === 'granted';
    }
    return false;
  };

  const loadSvgFromHandle = async () => {
    if (!fileHandle || isRefreshing) {
      return;
    }
    isRefreshing = true;
    try {
      const file = await fileHandle.getFile();
      if (file.lastModified === lastModified) {
        return;
      }
      const text = await file.text();
      await displaySvg(text, {
        filename: file.name,
        fileLastModified: file.lastModified,
        shouldAnnounceUpdate: true,
      });
    } finally {
      isRefreshing = false;
    }
  };

  const displaySvg = async (
    svgText,
    {
      filename = '',
      fileLastModified = null,
      shouldAnnounceUpdate = true,
    } = {}
  ) => {
    const parser = new DOMParser();
    const doc = parser.parseFromString(svgText, 'image/svg+xml');
    const svg = doc.documentElement;

    if (!svg || svg.tagName.toLowerCase() !== 'svg') {
      throw new Error('Arquivo selecionado nao parece ser um SVG valido.');
    }

    baseViewBox = computeBaseViewBox(svg);
    const zoom = ZOOM_FACTOR > 0 ? ZOOM_FACTOR : 1;
    const newWidth = baseViewBox.width / zoom;
    const newHeight = baseViewBox.height / zoom;
    const newMinX = baseViewBox.minX + OFFSET_X;
    const newMinY = baseViewBox.minY + OFFSET_Y;

    svg.setAttribute('viewBox', `${newMinX} ${newMinY} ${newWidth} ${newHeight}`);
    svg.removeAttribute('width');
    svg.removeAttribute('height');

    const serialized = new XMLSerializer().serializeToString(svg);

    const blob = new Blob([serialized], { type: 'image/svg+xml' });
    const nextObjectUrl = URL.createObjectURL(blob);
    preview.setAttribute('data', nextObjectUrl);
    preview.data = nextObjectUrl;
    preview.style.display = 'block';
    if (currentObjectUrl) {
      URL.revokeObjectURL(currentObjectUrl);
    }
    currentObjectUrl = nextObjectUrl;

    const effectiveLastModified =
      typeof fileLastModified === 'number' ? fileLastModified : Date.now();
    lastModified = effectiveLastModified;

    if (shouldAnnounceUpdate && filename) {
      updateStatus(
        `${filename} - atualizado ${new Date(effectiveLastModified).toLocaleTimeString()}`
      );
    }
  };

  const startAutoRefresh = () => {
    if (refreshTimer) {
      clearInterval(refreshTimer);
    }
    refreshTimer = setInterval(() => {
      loadSvgFromHandle().catch((error) => {
        console.error(error);
        updateStatus(`Erro ao atualizar: ${error.message}`);
      });
    }, REFRESH_INTERVAL_MS);
  };

  const selectWithFilePicker = async () => {
    try {
      const [handle] = await window.showOpenFilePicker({
        types: [
          {
            description: 'Arquivos SVG',
            accept: { 'image/svg+xml': ['.svg'] },
          },
        ],
        excludeAcceptAllOption: false,
        multiple: false,
      });

      const granted = await ensurePermission(handle);
      if (!granted) {
        throw new Error('Permissao de leitura negada.');
      }

      fileHandle = handle;
      baseViewBox = null;
      lastModified = 0;

      await loadSvgFromHandle();
      startAutoRefresh();
    } catch (error) {
      if (error.name === 'AbortError') {
        updateStatus('Selecao cancelada. Clique em "Selecionar SVG..." para tentar novamente.');
        return;
      }
      console.error(error);
      updateStatus(`Erro: ${error.message}`);
    }
  };

  const selectWithFileInput = async () => {
    if (!fileInput.files.length) {
      return;
    }
    const file = fileInput.files[0];
    fileHandle = null;
    baseViewBox = null;
    const text = await file.text();
    await displaySvg(text, {
      filename: file.name,
      fileLastModified: file.lastModified,
      shouldAnnounceUpdate: false,
    });
    updateStatus(`${file.name} - recarregue manualmente apos novas edicoes.`);
  };

  pickButton.addEventListener('click', () => {
    if (supportsFileSystemAccess()) {
      selectWithFilePicker();
    } else {
      fileInput.click();
    }
  });

  fileInput.addEventListener('change', () => {
    selectWithFileInput().catch((error) => {
      console.error(error);
      updateStatus(`Erro ao abrir arquivo: ${error.message}`);
    });
  });

  window.addEventListener('load', () => {
    if (supportsFileSystemAccess()) {
      updateStatus('Clique em "Selecionar SVG..." para escolher um arquivo.');
    } else {
      updateStatus('Clique em "Selecionar SVG..." e escolha um arquivo SVG (atualizacao automatica indisponivel neste navegador).');
    }
  });
</script>
